% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FCnetLOO.R
\name{FCnetLOO}
\alias{FCnetLOO}
\title{Leave-One-Out cross-validated fit of elastic nets for Functional Connectivity data}
\usage{
FCnetLOO(
  y,
  x,
  alpha = seq(0, 1, by = 0.1),
  lambda = rev(10^seq(-5, 5, length.out = 200)),
  parallelLOO = F,
  scale_y = T,
  type.measure = optionsFCnet("cv.type.measure"),
  intercept = optionsFCnet("intercept"),
  standardize = optionsFCnet("standardize"),
  ...
)
}
\arguments{
\item{y}{The dependent variable, typically behavioral scores to predict.
This can be a vector or a single data.frame column.}

\item{x}{The independent variables, typically neural measures that have
been already summarised through data reduction techniques
(e.g. ICA, PCA): an object created by \code{reduce_featuresFC()} will do. If such
an object is passed to this function, the "Weights" slot is taken as x.
A list can be passed to this function: in this case the function needs an
entry named "Weights". Otherwise, a data.frame can be passed to x.}

\item{alpha}{Value(s) that bias the elastic net toward ridge regression
(alpha== 0) or LASSO regression (alpha== 1). If a vector of alpha values
is supplied, the value is optimized through crossvalidation.
It defaults to a vector ranging from 0 to 1 with steps of 0.1.
The crossvalidated alpha is returned.}

\item{lambda}{Regularization parameter for the regression,
see \code{glmnet::glmnet()}. Lambda must be a vector with length>1.
When a vector of lambda values is supplied, the value of lambda
is optimized through internal crossvalidation. It defaults to a vector
ranging from 10^-5 to 10^5 with 200 values in logarithmic steps.
The crossvalidated optimal lambda is returned.}

\item{parallelLOO}{If TRUE - recommended, but not the default - uses
\code{future.apply::future_lapply()} for the outer loops: \code{future.apply} must be
installed, the machine should have multiple cores available for use,
and threads should be defined explicitly beforehand by the user
(e.g. by calling \code{plan(multisession)}).}

\item{scale_y}{Whether y should be scaled prior to fit. Default, TRUE, scales and center y with
\code{scale()}.}

\item{intercept}{whether to fit (TRUE) or not (FALSE) an intercept to the model.}

\item{standardize}{Whether x must be standardized.
\code{glmnet::glmnet()} the default is FALSE as we assume predictors are already either
summarised with PCA or ICA (and therefore scaled) or drawn from normalized FC matrices.}

\item{...}{Other parameters passed to \code{glmnetUtils::cva.glmnet()} or
\code{glmnet::glmnet()}.}

\item{cv.type.measure}{The measure to minimize in crossvalidation inner loops.
Differently from \code{glmnetUtils::cva.glmnet()} the default is the mean absolute error.}
}
\value{
A model produced by \code{glmnet::glmnet()}.
Crossvalidated best alpha and lambda values.
If requested: a vector of observed (y) and predicted (predicted) values;
model's coefficients; goodness of fit statistics.
}
\description{
This function is a wrapper around \code{glmnet::glmnet()} as called from
\code{FCnet::FCnet()}. For extended documentation,
the readers are encouraged to consult the original source of \code{glmnet::glmnet()}
and its vignette. \code{glmnet::glmnet()} fits a robust linear model through
penalized maximum likelihood computed via the lasso or elastic net
regularization path.
\code{FCnetLOO()} requires two objects at minimum: \code{y} is a vector or data.frame
with exactly one column, corresponding to the (behavioral) score to predict; \code{x}
is a data.frame or a list of lists with an entry named "Weights",
which includes the independent variables. \code{x} can be - and is meant to be -
one object created by \code{reduce_featuresFC()}, but this is not strictly necessary.
The best model and hyperparameters are retrieved in inner loops through \code{cv_FCnet()};
details of the crossvalidation procedures can be passed as arguments to
\code{FCnetLOO()} if necessary.
A call to \code{FCnetLOO()} returns a list including goodness of fit measures
for the outer loop, a data.frame including coefficients for all nested models,
vectors of crossvalidated parameters, and predicted scores.
Note that dependent variables are scaled by default through \code{scale_y}.
The \code{ParallelLOO} option is recommended for speed. In order to use parallel
computing, \code{future.apply} must be installed, your machine should have
multiple cores available, and parallel computing should be prompted by
the user (e.g. via \verb{plan(multisession}).
}
