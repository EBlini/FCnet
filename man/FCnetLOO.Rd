% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FCnetLOO.R
\name{FCnetLOO}
\alias{FCnetLOO}
\title{Leave-One-Out fit of elastic nets for Functional Connectivity data with nested crossvalidation}
\usage{
FCnetLOO(
  y,
  x,
  alpha = seq(0, 1, by = 0.1),
  lambda = rev(10^seq(-5, 5, length.out = 200)),
  cv_Ncomp = NULL,
  parallelLOO = F,
  scale_y = T,
  scale_x = T,
  type.measure = optionsFCnet("cv.type.measure"),
  intercept = optionsFCnet("intercept"),
  standardize = optionsFCnet("standardize"),
  ...
)
}
\arguments{
\item{y}{The dependent variable, typically behavioral scores to predict.
This can be a vector or a single data.frame column.}

\item{x}{The independent variables, typically neural measures that have
been already summarised through data reduction techniques
(e.g. ICA, PCA): an object created by \code{reduce_featuresFC()} will do. If such
an object is passed to this function, the "Weights" slot is taken as x.
A list can be passed to this function: in this case the function needs an
entry named "Weights". Otherwise, a data.frame can be passed to x.}

\item{alpha}{Value(s) that bias the elastic net toward ridge regression
(alpha== 0) or LASSO regression (alpha== 1). If a vector of alpha values
is supplied, the value is optimized through nested crossvalidation.
It defaults to a vector ranging from 0 to 1 with steps of 0.1.
The crossvalidated alpha is returned.}

\item{lambda}{Regularization parameter for the regression,
see \code{glmnet::glmnet()}. Lambda must be a vector with length>1.
When a vector of lambda values is supplied, the value of lambda
is optimized through internal nested crossvalidation. It defaults to a vector
ranging from 10^-5 to 10^5 with 200 values in logarithmic steps.
The crossvalidated optimal lambda is returned.}

\item{cv_Ncomp}{Whether to crossvalidate the number of components or not.
It defaults to NULL, but a vector can be supplied specifing the number of
components to test in the inner loops.}

\item{parallelLOO}{If TRUE - recommended, but not the default - uses
\code{future.apply::future_lapply()} for the outer loops: \code{future.apply} must be
installed, the machine should have multiple cores available for use,
and threads should be defined explicitly beforehand by the user
(e.g. by calling \code{plan(multisession)}).}

\item{scale_y}{Whether y should be scaled prior to fit. Default, TRUE, scales and center y with
\code{scale()}.}

\item{scale_x}{Whether x should be scaled prior to fit. Default, TRUE, subtracts
the mean matrix value and divides each entry for the matrix variance.
Beware that this adds to \code{optionsFCnet("standardize")}.}

\item{intercept}{whether to fit (TRUE) or not (FALSE) an intercept to the model.}

\item{standardize}{Whether x must be standardized.}

\item{...}{Other parameters passed to \code{glmnetUtils::cva.glmnet()} or
\code{glmnet::glmnet()}.}

\item{cv.type.measure}{The measure to minimize in crossvalidation inner loops.
Differently from \code{glmnetUtils::cva.glmnet()} the default is the mean absolute error.}
}
\value{
Goodness of fit statistics for the outer loops, as well as LOO predictions.
Crossvalidated best alpha and lambda values for the inner loops as well as
all inner models' coefficients combined..
}
\description{
This function is a wrapper around \code{glmnet::glmnet()} as called from
\code{FCnet::cv_FCnet()}. For extended documentation,
the readers are encouraged to consult the original source of \code{glmnet::glmnet()}
and its vignette. \code{glmnet::glmnet()} fits a robust linear model through
penalized maximum likelihood computed via the lasso or elastic net
regularization path.
\code{FCnetLOO()} requires two objects at minimum: \code{y} is a vector or data.frame
with exactly one column, corresponding to the (behavioral) score to predict; \code{x}
is a data.frame or a list of lists with an entry named "Weights",
which includes the independent variables. \code{x} can be - and is meant to be -
one object created by \code{reduce_featuresFC()}, but this is not strictly necessary.
The best model and hyperparameters are retrieved in inner loops through \code{cv_FCnet()};
details of the crossvalidation procedures can be passed as \code{...} arguments to
\code{FCnetLOO()} if necessary.
A call to \code{FCnetLOO()} returns a list including goodness of fit measures
for the outer loop, a data.frame including coefficients for all nested models,
vectors of crossvalidated parameters, and predicted scores.
Note that dependent variables are scaled by default through \code{scale_y}.
The \code{ParallelLOO} option is recommended for speed. In order to use parallel
computing, \code{future.apply} must be installed, your machine should have
multiple cores available, and parallel computing should be prompted by
the user (e.g. via \verb{plan(multisession}).
}
